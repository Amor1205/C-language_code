#define _CRT_SECURE_NO_WARNINGS
//数组
//1.一维数组的创建和初始化
//1.1 数组的创建
//数组是一组相同类型元素的集合。
// type_t     arr_name    [const_n]
// 元素类型   数组名称    常量个数
// int        arr         [10] 

//在C99标准之前，数组大小必须书常量或者常量表达式。
//在C99之后，数组的大小可以是变量，为了支持变长数组。
//如 int arr2[n] (只能在支持C99标准的编译器上使用，并且先初始化n，变长数组不能初始化)
//gcc编译器上支持

//1.2 数组的初始化
//
//数组在内存中是连续存放的
//int main()
//{
//	//不完全初始化，剩余元素默认为0
//	int arr[10] = { 1,2,3 };
//	//不完全初始化，剩余元素默认为0， 就是'\0'
//	char ch1[10] = { 'a','b','c' };
//	//不完全初始化，和上面的区别是上面初始化3个元素，下面四个a,b,c,\0
//	char ch2[10] = { "abc" };
//	return 0;
//}
//
//int main()
//{
//	int arr[] = { 0,1,2,3,4,5,6,7,8,9 };
//	//
//	//[] - 下表引用操作符
//	//printf("%d\n",arr[4]);
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);//10
//	for (i = 0; i < sz; i++)
//	{
//		printf("%d\n", arr[i]);
//	}
//打印地址%p , 后面需要取地址&
//数组为整型类型的地址，都差四个字节
//随着数组小表的增长，元素的地址，在有规律的递增--->数组在内存中是连续存放的。

//2.二维数组的创建和初始化
//数组创建
//#include<stdio.h>
//int main()
//{
//	//存放1 2 3 4
//	//    2 3 4 5
//	//    3 4 5 6
//	int arr1[3][4]; //3行4列
//	int arr2[3][4] = { 1,2,3,4,2,3,4,5,3,4,5,6 }; //依次放入，若不够则填0
//	int arr3[3][4]={{1,2},{3,4},{5,6}};//数据不够，分组
//	int arr4[][4] = { {1,2,3,4},{1,2} }; //二维数组可以省略行，但是不可以省略列
//	int i = 0;
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 4; j++)
//		{
//			printf("%d ", arr2[i][j]);
//		}
//		printf("\n");
//	}
//	return 0;
//}
//二维数组可以看作行的一维数组的数组

//二维数组在内存中的存储
//二维数组在内存中也是连续存放的

//数组越界
//数组的小表示有范围限制的
//数组的下标定时从0开始的如果数组有n个元素，最后一个元素的下标就是n-1
//所以数组的小表如果小于0，或者大于n-1，就是数组越界访问了，超出了数组合法空间的访问。
//C语言本身是不做数组效标的越界检查，编译器也不一定报错，但是不代表程序是正确的。
//所以要自己检验数组越界与否。

//应用：数组作为函数参数

//冒泡排序的算法，对数组进行排序

//冒泡排序：核心思想，两个相邻元素进行比较，不满足顺序则调整顺序

//数组传参的时候，形参有两种写法。
//1.数组
//void bubble_sort(int arr[])//形参是数组的形式,一定写[] 否则是整型
//2.指针

//#include<stdio.h>
//
//void bubble_sort(int* arr,int sz)//自己写的不知道对不对。
//{
//	//int sz = sizeof(arr) / sizeof(arr[0]);//sz不可以在内部求！数组名本质上是数组首元素的地址
//	for (int i = 0; i < sz - 1; i++)
//	{
//		for (int j = 0; j < sz - 1 - i; j++)
//		{
//			if (arr[j] > arr[j + 1])
//			{
//				int tmp = arr[j];
//				arr[j] = arr[j + 1];
//				arr[j + 1] = tmp;
//			}
//		}
//	}
//}
//int main()
//{
//	int arr[] = { 9,8,7,6,5,4,3,2,1 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	bubble_sort(arr,sz);
//	int i = 0;
//	for (i = 0; i < sz; i++)
//		printf("%d ", arr[i]);
//	return 0;
//}

//二维数组不是用二级指针

//4.数组名
//#include<stdio.h>
//int main()
//{
//	int arr[10];
//	printf("%p\n", arr);
//	printf("%p\n", arr+1);
//	printf("%p\n", &arr[0]); //和arr相同，都是首元素地址
//	printf("%p\n", &arr[0]+1); //数组首元素的地址加1，
//	printf("%d\n", sizeof(arr)); //40 这时候数组名又不是首元素地址了。
//	printf("%p\n", &arr);  //数组的地址
//	printf("%p\n", &arr+1);//数组的地址加一，其内存中是加了10（元素数）*整型字节4
//	return 0;
//}
//数组名确实能表示首元素的地址
//但是有两个例外
//1.sizeof(数组名)，这里的数组名表示整个数组，计算的是整个数组的大小，单位是字节。
//2.&数组名，这里的数组名也表示整个数组，取出的是整个数组的地址。

//二维数组的数组名的理解
//#include<stdio.h>
//int main()
//{
//	int arr[3][4];
//	int sz = sizeof(arr);
//	printf("%d\n", sizeof(arr) / sizeof(arr[0]));//打印出行的个数
//	printf("%d\n", sizeof(arr[0]) / sizeof(arr[0][0]));//打印列的个数
//	printf("%d\n", sz);
//	//arr;//二维数组的数组名也表示数组首元素的地址
//	printf("%p\n", arr); //表示的这一行的地址。（因为二维数组的第一行相当于一维数组的首元素）
//	printf("%p\n", arr+1); //相比上面加了16 多了16/4等于四个，一行的地址
//	printf("%p\n", &arr);
//	printf("%p\n", &arr + 1);//相比上面多了48
//	return 0;
//}

//利用数组
//1.实现三子棋
//2.扫雷游戏
