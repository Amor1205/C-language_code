481.神奇字符串

>
>
>神奇字符串 s 仅由 '1' 和 '2' 组成，并需要遵守下面的规则：神奇字符串 s 的神奇之处在于，串联字符串中 '1' 和 '2' 的连续出现次数可以生成该字符串。
>s 的前几个元素是 s = "1221121221221121122……" 。如果将 s 中连续的若干 1 和 2 进行分组，可以得到 "1 22 11 2 1 22 1 22 11 2 11 22 ......" 。每组中 1 或者 2 的出现次数分别是 "1 2 2 1 1 2 1 2 2 1 2 2 ......" 。上面的出现次数正是 s 自身。
>
>给你一个整数 n ，返回在神奇字符串 s 的前 n 个数字中 1 的数目。
>
>来源：力扣（LeetCode）
>链接：https://leetcode.cn/problems/magical-string
>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

法1:

> 1组和2组交替出现，重要的是1和2每次出现的次数，可以通过字符串本身来知道。构造到s的长度达到n为止。
>
> 但是最后一次可能会填入两个数字，导致s的长度为n+1，因此我们需要统计s的前n个字符，而非所有字符。
>
> ```c++
> class Solution {
> public:
>     int magicalString(int n) {
>         string s = "\1\2\2"; // 值就是 1,2,2，这样就可以直接用 s[i] 当作个数
>         for (int i = 2; s.length() < n; ++i)
>             s += string(s[i], s.back() ^ 3); // 1^3=2, 2^3=1，这样就能在 1 和 2 之间转换
>         return count(s.begin(), s.begin() + n, 1);
>     }
> };
> ```
>
> 其中用到的知识点：
>
> 1. \1 反斜杠+数字，是转换为字符，\1代表着字符1，\2代表着字符2.这样我们在构造临时对象string时，用char类型而非int类型，否则还需要隐式类型转换。
> 2. string(size_t n, char ch) 是一种字符串构造方式，表示构造n个ch的字符串。
> 3. count(s.begin(), s.begin()+n, 1);是一种计数方式，用迭代器计数，最后一位是需要查找的字符。

法2:

>根据我们的分析，这串字符串实际上是唯一的，也就是说，无论是构造n=100的字符串，还是n=1000的字符串，都是同样的字符串，即每个字符串1和2出现的位置都是相同的，我们可以先构建一个10000长度的字符串，然后再创建一个数组用来统计出现的次数，如果传过来n我们直接拿数组里统计好的次数返回即可。
>
>```c++
>const int MAX = 1e5;
>int countarr[MAX + 1];
>
>int init = []()
>{
>	string s = "\1\2\2";
>	//构造字符串
>	for(int i = 2;s.size()<MAX;++i)
>	{
>		s += string(s[i],s.back^3);
>	}
>	//统计次数
>	for(int i = 0;i<MAX;++i)
>	{
>		countarr[i+1] = countarr[i] + 2 -s[i];
>	}//s[i]为1或2，2-1 = 1， 2-2 = 0
>	return 0;
>}
>class Solution {
>public:
>    int magicalString(int n) {
>        return countarr[n];
>    }
>};
>```

1.两数之和

>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
>
>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
>
>你可以按任意顺序返回答案。
>
>来源：力扣（LeetCode）
>链接：https://leetcode.cn/problems/two-sum
>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

法1:

>