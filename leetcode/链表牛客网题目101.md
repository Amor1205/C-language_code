# 开头



## **BM1** **反转链表**

### 题目叙述

给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。 

数据范围： 0≤n≤10000≤*n*≤1000

要求：空间复杂度 O(1)*O*(1) ，时间复杂度 O(n)*O*(*n*) 。 

如当输入链表{1,2,3}时， 

经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。 

以上转换过程如下图所示：

![CleanShot 2023-01-24 at 01.38.28@2x](/Users/amor/Library/Application Support/CleanShot/media/media_3T2SjweVy8/CleanShot 2023-01-24 at 01.38.28@2x.png)

### 解题思路：

**思路1： 通过栈的方式反转链表。**

链表的反转是面试中常考的一道题。最简单的一种方式就是使用栈，因为栈是先进后出的。实现原理就是把链表节点一个个入栈，当全部入栈完之后再一个个出栈，出栈的时候在把出栈的结点串成一个新的链表。原理如下

<img src="/Users/amor/Downloads/IMG_6CC992CE140F-1.jpeg" alt="IMG_6CC992CE140F-1" style="zoom:50%;" />

代码如下：

```c++
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
		if(pHead == nullptr)
			return nullptr;
		else if (pHead->next == nullptr)
			return pHead;
		stack<ListNode*> st;
		ListNode* cur = pHead;
		while(cur != nullptr)
		{
			st.push(cur);
			cur = cur->next;
		}
		ListNode* top = st.top();
		ListNode* head = st.top();
		while(!st.empty())
		{
			top = st.top();
			st.pop();
			if(st.empty())
			{
				top->next = nullptr;
				break;
			}
			else	
				top->next = st.top();
		}
		return head;
    }
};
```

思路2：递归解决

递归的模板是终止条件+递归调用+逻辑处理。本题目中终止条件是链表为空或链表下一个指向为空，返回即可。逻辑处理分为再递归调用前和递归调用后。本次使用递归调用前的逻辑处理负责向下传递，一直走到尾节点，使用递归调用后的逻辑处理负责修改指向。

```c++
	//终止条件
	if(pHead == nullptr || pHead->next == nullptr)
		return pHead;
	//保存next，递归调用时会一直走到尾节点
	ListNode* next = pHead->next;
	//带返回值的递归调用
	ListNode* ret = ReverseList(next);
	//修改next指向前面
	next->next = pHead;
	//前面指向空，如果不加这句话会形成环
	pHead->next = nullptr;
	return ret;
```

这种递归往下传递的时候基本上没有逻辑处理，当往回反弹的时候才开始处理，也就是从链表的尾端往前开始处理的。我们还可以再来改一下，借用子函数，在链表递归的时候就从前往后处理，处理完之后**直接返回递归的结果**，这就是所谓的尾递归，这种运行效率要比上一种好很多。尾递归虽然也会不停的压栈，但由于最后返回的是递归子函数的返回值，所以在返回的时候都会一次性出栈，不会一个个出栈这么慢。

```c++
class Solution {
public:
	ListNode* _reverseList(ListNode* head, ListNode* newHead)
	{
		if(head == nullptr)
			return newHead;
		ListNode* next = head->next;
		head->next = newHead;
		return _reverseList(next,head);
	}
    ListNode* ReverseList(ListNode* pHead) {
			return _reverseList(pHead,nullptr);
    }
};
```

如果把递归子函数的返回值保存后返回，就又会开始一个一个出栈，效率比一开始的递归代码没有提升，所以使用时注意区分。如下：

```c++
class Solution {
public:
	ListNode* _reverseList(ListNode* head, ListNode* newHead)
	{
		if(head == nullptr)
			return newHead;
		ListNode* next = head->next;
		head->next = newHead;
    ListNode* ret = _reverseList(next,head);
		return ret;
	}
    ListNode* ReverseList(ListNode* pHead) {
			return _reverseList(pHead,nullptr);
    }
};
```

