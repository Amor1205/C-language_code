#include <stdio.h>
//
//
//结构：结构式一些值得集合，这些只被称为成员变量。结构的每个成员可以是不同类型的变量。
//结构的声明：
// struct tag
// {
//     member - list;
// } variable - list;
// e.g.
//学生
// struct Stu//可以不写Stu，是匿名结构体类型
// {
//     char name[20];
//     int height;
//     int age;
//     //name，height，age就是成员列表member list
// };
// //可以不放，也可以放s1，s2等等。
// //放就是相当于创建结构体变量了variable list(struct Stu)类型(全局变量)
// //分号不能丢

// int main()
// {
//     struct Stu s3;//是局部变量
//     return 0;
// }

//数据结构
//数据在内存中的存储结构
//如，有线性，如顺序表（连续存放），链表（1节点包含2节点，就可以找到2，以此类推）
// struct Node//node就是节点
// {
//     int data;//存放数据，数据域
//     struct Node* next;//存放指针，指针域
// };
// //树形，如二叉树
// int main()
// {
//     int r = sizeof(struct Node);
//     printf("%d\n", r);
//     return 0;
// }
//这样类似Node的结构体的成员列表里包含同类型的结构体指针的情况，就叫做结构体自引用。

//我们写结构体
// struct Node
// {
//     int data;
//     struct Node *next;
// };
//每次都写struct Node太过繁琐，想要简单写，可以这样定义：
// typedef struct Node
// {
//     int data;
//     struct Node *next;
// } Node;
//这样就是typedef重命名strcut Node为Node，以后就可以简写了。

//当然，我们可以在创建类型的同时进行初始化
// struct A
// {
//     int x;
//     int y;
// } a1 = {2, 3};
//这就是创建A类型的同时进行a1变量的创建
// a1.x,a1.y 用'.'可以找到结构体内的成员

// 1.6结构体内存对齐
// struct S1
// {
//     char c1;
//     int i;
//     char c2;
// };
// struct S2
// {
//     char c1;
//     char c2;
//     int i;
// };
// struct S3
// {
//     double d; // 8
//     char c;   // 9
//     int i;    // 12-15
//     // 16
// };
// struct S4
// {
//     char c1;      // 0-1
//     struct S3 s3; // 8-23
//     double d;     // 24-31
//     // 32
// };
// int main()
// {
//     printf("%d\n", sizeof(struct S1)); // 12
//     printf("%d\n", sizeof(struct S2)); // 8
//     return 0;
// }
//结构体的内存大小并不是直接成员内存大小相加，遵循对齐规则：
// 1.第一个成员在与结构体变量偏移量为0的地址处。
// 2.其他成员变量要对齐到某个数字(对齐数)的整数倍的地址处。
//对齐数 = 编译器默认的第一个对齐数与该成员大小的较小值。
// vs中默认的值为8；其他的编译器没有默认对齐数
// 3.结构体总大小为最大对齐数(每个成员变量都有一个对齐数)的整数倍。
// 4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数(含嵌套结构体的对齐数)的整数倍。

//为什么存在内存对齐？
// 1. 平台原因(移植原因）：
// 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
// 2. 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
// 总体来说：
// 结构体的内存对齐是拿空间来换取时间的做法。
//
//但是可以通过让占用空间小的成员尽量集中到一起。
//
// 1.7修改默认对齐数
//通过#pragma pack()就可以修改默认对齐数
//如果#pragma pack()括号内为空，则恢复默认对齐数
// struct S
// {
//     int i;//0-3
//     double d;//8-15
//     //16
// };
// #pragma pack(4)
// struct S1
// {
//     int i;
//     double d;
// };
// #pragma pack()
// int main()
// {
//     printf("%d\n", sizeof(struct S));//16
//     printf("%d\n", sizeof(struct S1));//12
//     return 0;
// }
//但是最好不要乱改，否则会造成读取数据的不便
//#pragma once 在头文件中使用，功能是防止头文件被多次引用

// 1.8结构体传参
//  struct S
//  {
//      int data[1000];
//      int num;
//  };
//  void print1(struct S ss)
//  {
//      int i = 0;
//      for (i = 0; i < 3;i++)
//      {
//          printf("%d ", ss.data[i]);
//      }
//      printf("%d\n", ss.num);
//  }
//  void print2(const struct S* ps)
//  {
//      for (int i = 0; i < 3;i++)
//      {
//          printf("%d ", ps->data[i]);
//      }
//      printf("%d\n", ps->num);
//  }
//  int main()
//  {
//      struct S s = {{1, 2, 3}, 100};
//      print1(s);//传值调用，如果直接传值，会造成参数压栈，会对空间和时间造成压迫
//      print2(&s);//传址调用，直接传地址，节省空间而且快
//      //两种方式，优先选择传址调用。->
//      return 0;
//  }
//函数栈针一定要看
//

// 2.位段
//位段的声明和结构是类似的，但是有两个不同。
//-1.位段的成员必须是int、unsignd int、signed int。
//-2.位段的成员名后面有一个冒号和一个数字

//位段其实就是用来节省空间的。

// 比如
// struct A
// {
//     int _a : 2;
//     int _b : 5;
//     int _c : 10;
//     int _d : 30;
// };
// A就是一个位段类型，位就是指的是比特位
//冒号后面的数字就是需要的比特位的个数， a：2就代表a只需要两个bit位
// int main()
// {
//     printf("%d\n", sizeof(struct A));//8
//     return 0;
// }
// 8个比特位 -- 1个字节byte
// 2.2位段的内存分配
// 1.位段成员可以是整型家族。
// 2.位段的空间时按照需要以4个字节(int),1个字节(char)来开辟，如果不够继续开辟。
// 3.位段涉及很多不确定因素，位段是不跨平台的，注意可移植的程序应该避免使用位段

// struct S
// {
//     char a : 3; //+1byte
//     char b : 4;
//     char c : 5; //+1byte
//     char d : 4; //+1byte
// };
// int main()
// {
//     struct S s = {0};
//     s.a = 10;//1010 只有三个bit位的空间，放不下就嗯放，放010
//     s.b = 12;//1100 能放下1100
//     //如果从右向左放置
//     //1byte -> 01100010 -- 62
//     s.c = 3;// 00000011 -- 03
//     s.d = 4;// 00000100 -- 04
//     return 0;
// }
// 2.3 位段的跨平台问题

// 1. int 位段被当成有符号数还是无符号数是不确定的。 
// 2. 位段中最大位的数目不能确定。（16位机最大16，32位机器最大32，写成27，在16位机器会出问题。 
// 3.位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。 
// 4. 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。
// 总结：跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在。

// 2.4 位段的应用