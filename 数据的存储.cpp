#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
//int main()
//{
//	int i = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//
//	printf("%p\n", arr);
//	printf("%p\n", &i);
//
//	/*for (i = 0; i <= 12; i++)
//	{
//		arr[i] = 0;
//		printf("hehe\n");
//	}*/
//	return 0;
//}
//i 比 arr数组的地址高，越界可能会访问i从而导致死循环
// 
//在debug版本时编译器会死循环
//在release版本下并未死循环
//是因为release版本下会对代码进行一个优化
//导致i 比 arr数组的地址低，低地址不会被越界访问。
//

//从头开始，认真学习
//
//数据类型介绍
// char   1 
// short  2
// int    4 
// long   4/8   c只规定了sizeof(long)>=sizeof(int) 32位用4字节，64位8字节
// longlong c99引入的  8
// float 单精度浮点数  4
// double 双精度浮点数 8
//
// 整型家族：char,short,int,long,longlong 都有unsigned n signed 
// 字符的本质是Ascii码值，是整型，所以划分到整型家族
// char ---> (signed char  or  unsigned char)  up to 编译器
// 
// 生活中有的数值没有正负数，这种情况下需要用unsigned 类型
// 否则用 signed (需要用负数)
// 
// 浮点数家族：float, double 
// float 的精度低，存储的数值范围较小，double的精度高，存储的数据范围更大。
//
// 构造类型：自定义类型 -- 我们可以自己创建出新的类型
// > 数组类型 eg. int arr1[5]; 只要是创建出自己想要的类型就叫构造类型，所以数组也是。
// > 结构体类型 struct
// > 枚举类型  enum
// > 联合类型 union
//

// 空类型: void表示空类型(无类型)
//

//数值有不同的表示形式:2进制，8进制，10进制，16进制等
//十进制的21
//2进制:0b10101,8进制:025,16进制:0x15
//2进制 0b前缀
//8进制 0前缀
//16进制 0x前缀

//整数的2进制表示也有三种表示形式
//原码, 反码, 补码
// 正的整数原码反码补码相同，负的整数原码反码补码需要计算
// 
//原码，根据数据的数值正负直接写出来的
//反码，把原码符号位不变，其他按位取反
//补码，反码+1

//e.g.
// 20 (signed int)
// 0000 0000 0000 0000 0000 0000 0001 0100
// 0x 00 00 00 14 （4个二进制位写成一个16进制位）
// 0000 0000 0000 0000 0000 0000 0001 0100
// 0000 0000 0000 0000 0000 0000 0001 0100
//
// -10（signed int）
// 1000 0000 0000 0000 0000 0000 0000 1010 -- 原码
// 0x 80 00 00 0a
// 1111 1111 1111 1111 1111 1111 1111 0101 -- 反码
// 0x ff ff ff f5
// 1111 1111 1111 1111 1111 1111 1111 0110 -- 补码
// 0x ff ff ff f6
//

//大端字节序存储：把一个数据的高位字节序的内容存放在低地址处，把低位字节序内容放在高地址处。
//小端字节序存储
//现在的所有的计算机都采用小端字节序存储。

//写一个程序判断是大端还是小端
//
//
//int main()
//{
//	int a = 1;
//	//0x 00 00 00 01
//	//如果大端 00 00 00 01
//	//如果小端 01 00 00 00
//	//用char强制类型转换
//	if ((char)a == 1)
//		printf("小端\n");
//	else
//		printf("大端\n");
//	return 0;
//}

//char, signed char, unsigned char 的范围是多少？
// 8个bit位上面可能的数字是0000 0000 --- 1111 1111
// 如果是signed char 第一位是符号位，只有后面7位是表示大小的。所以最大为2的7次方-1 = 127；
//  signed char 的范围就是-128 ~ 127 （1000 0000会直接转变成 -128）
//	unsigned char 范围就是0 ~ 255
// 
// 同理 signed short  -32768 ~ 32767
//      unsigned short 0 ~ 65535

//int main()
//{
//	char a = -1;
//	//首先写出来-1的原码：
//	// 原码：1000 0000 0000 0000 0000 0000 0000 0001
//	// 反码：1111 1111 1111 1111 1111 1111 1111 1110
//	// 补码：1111 1111 1111 1111 1111 1111 1111 1111
//	// 因为char只能放入8个bit位，故，截断
//	// 补码：1111 1111 
//	// 在内存中存储的是1111 1111
//	// 打印的时候是%d打印，所以还需要把char整型提升
//	// %d：有符号整型打印
//	// 1111 1111 1111 1111 1111 1111 1111 1111
//	// 取反+1 得到原码 值为-1 
//	// 
//	signed char b = -1;
//	//
//	//因为signed char取值范围是-128 ~ 127
//	//放入-1没问题
//	//
//	unsigned char c = -1;
//	//无符号数 1111 1111  --- 255 
//	//0000 0000 0000 0000 0000 0000 1111 1111 --- 255 
//	printf("a=%d,b=%d,c=%d", a, b, c);
//
//	return 0;
//}

//int main()
//{
//	char a = -128;
//	//因为char的范围是-128`127，-128在其范围内，
//	//1000 0000 0000 0000 0000 0000 1000 0000
//	//1111 1111 1111 1111 1111 1111 0111 1111
//	//1111 1111 1111 1111 1111 1111 1000 0000
//	//截断
//	//1000 0000
//	//提升
//	//1111 1111 1111 1111 1111 1111 1000 0000 
//	// 因为unsigned int 补码等于原码等于反码，所以直接当原码解，得到的是一个非常大的正数。
//	//
//	char b = 128;
//	// 原码：0000 0000 0000 0000 0000 0000 1000 0000
//	// 反码：0000 0000 0000 0000 0000 0000 1000 0000
//	// 补码：0000 0000 0000 0000 0000 0000 1000 0000
//	// 截断：1000 0000
//	// 提升：依然是 1111 1111 1111 1111 1111 1111 1000 0000
//	// ----- ：： 但是 如果存128实际上存不进去，因为char的范围是-128~127
//	printf("%u\n", a);
//	return 0;
//}

//int main()
//{
//	int i = -20;
//	// 原码：1000 0000 0000 0000 0000 0000 0001 0100
//	// 反码：1111 1111 1111 1111 1111 1111 1110 1011
//	// 补码：1111 1111 1111 1111 1111 1111 1110 1100
//	// 截断：1110 1100
//	// 提升：1111 1111 1111 1111 1111 1111 1110 1100
//	// 取反：1000 0000 0000 0000 0000 0000 0001 0011
//	// +1  ：1000 0000 0000 0000 0000 0000 0001 0100
//	// -20
//	unsigned int j = 10;
//	// 原码：0000 0000 0000 0000 0000 0000 0000 1010
//	// 反码：0000 0000 0000 0000 0000 0000 0000 1010
//	// 补码：0000 0000 0000 0000 0000 0000 0000 1010
//	// 截断：0000 1010
//	// 提升：0000 0000 0000 0000 0000 0000 0000 1010
//	// 10
//	printf("%d\n", i + j);
//	return 0;
//	
//
////按照补码的形式进行运算，最后格式化成为有符号整数。
//}
#include<windows.h>
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);
//		Sleep(1000);//休眠1000ms,为了观察程序的运行过程，需要引用windows.h头文件
//	}
//	return 0;
//}

//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	// a[0] = -1;      1000 0001
//	// 过程： -1 -0 = -1， 
//	// -1 
//	// 原码：1000 0000 0000 0000 0000 0000 0000 0001
//	// 反码：1111 1111 1111 1111 1111 1111 1111 1110
//	// 补码：1111 1111 1111 1111 1111 1111 1111 1111
//	// 截断：1111 1111
//	// char 类型：
//	// 补码：1111 1111
//	// 取反：1000 0000
//	// 加一：1000 0001（原码），为-1
//	// 
//	// a[1] = -2;      1000 0010
//	// ......  -127    1000 0001 翻译成-127
//	// a[127] = -128;  1000 0000 翻译成-128
//	// -129 
//	// 原码：1000 0000 0000 0000 0000 0000 1000 0001
//	// 反码：1111 1111 1111 1111 1111 1111 0111 1110
//	// 补码：1111 1111 1111 1111 1111 1111 0111 1111
//	// 截断：0111 1111
//	// ---> 127
//	// a[128] = 127
//	// -1 -2 -3 -4 ...... -128 127 ... 3 2 1 0
//	// 0之前有255个数字
//	printf("%d", strlen(a));
//	//strlen求字符串长度，关注的是字符串中'\0'（数字0）之前出现多少字符
//	return 0;
//}

//unsigned char i = 0;
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello world\n");
//	}
//	return 0;
//}
//看都不用看直接死循环，因为unsigned char 范围就是0-255 这个for循环限制的

// strlen 返回值类型是size_t类型，unsigned int类型

//无符号数 和有符号数相加，转换成无符号数。
//整型家族的一些规定在limits.h中

//浮点型在内存中的存储
//3.14159
//1E10 (1.0乘以十的10次方)
// 包括float double 
//浮点型的一些规定在float.h中

//浮点数存储规则
// 只要是二进制浮点数，都可以写成
// V = (-1)^S * M * 2^E
// (-1)^S 符号位， s = 0 / 1
// M * 2^E 把十进制转换为二进制的科学计数法
// 
// e.g. V = 5.0f
//        = 101.0 = 1.01 * 2^2 = (-1)^0 * 1.01 * 2^2
// 
// 浮点数很有可能在内存中不能精确存储
// 32位浮点数，最高一位是s，接着八位是e，剩下的为m(把1.省略)
// 64位浮点数，最高一位是s，接着11位是e，剩下的为m(把1.省略)
// 规定e为无符号整数 unsigned int， 但是真实情况下，可能有负数，
// 所以加上一个中间值(8位的 加127，11位的 加1023)
// 
// E从内存中取出来分成三种情况
// E不全为0或者不为全1:E的内存值减去中间值127得到真实E，M补上1.即可
// 
// E全为0：真实的E就是-127或者更小，是一个无限接近于0的数字，直接规定为0
// 
// E全为1：如果有效数字M = 0 ，则是无穷大
// 

int main()
{
	int n = 9;
	// 0000 0000 0000 0000 0000 0000 0000 1001
	
	float* pFloat = (float*)&n;
	printf("n的值为:%d\n", n);
	printf("pFloat的值为:%f\n", *pFloat);
	// s = 0 , E全0，则为0
	*pFloat = 9.0;
	// 1001.0 = 1.001 * 2^3 
	// S = 0, E = 3+127 , M =001
	// 0 1000 0010 001 0000 0000 0000 0000 0000
	// 0100 0001 0001 0000 0000 0000 0000 0000
	// 用%d打印是一个巨大的数字
	printf("num的值为:%d\n", n);
	printf("*pFloat的值为:%f\n", *pFloat);
	return 0;
}
