//小乐乐上课需要走n阶台阶，因为他腿比较长，所以每次可以选择走一阶或者走两阶，那么他一共有多少种走法？
//输入描述：
//输入包含一个整数n(1 ≤ n ≤ 30)
//输出描述：
//输出一个整数，即小乐乐可以走的方法数。

//经典的斐波那契系题目(走台阶、青蛙跳、汉诺塔、兔子繁衍等) 1 1 2 3 5 8 13 21 34 55 89
//递归解题思路：递推 + 回归
//
//第一步，递推：目标是想求n级台阶有多少种走法，现在先假设已经走完了n级台阶同时假设存在f(n)种走法可以走完n级台阶，现在退回到走完这n级台阶的上一步，即走完这n级台阶的最后一步，最后一步有两种可能的情况，第一种情况是这一步只走了1级台阶，即完成最后一步之前已经走了n - 1级台阶，假设走完n - 1级台阶存在f(n - 1)种走法；第二种情况是最后一步走了两级台阶，即完成最后一步之前已经走了n - 2级台阶，又假设走完n - 2级台阶存在f(n - 2)种走法，那么理一下思路：完成n级台阶最后一步之前需要走完n - 1级台阶或者n - 2级台阶，因为n级存在台阶f(n)种走法，n - 1级台阶存在f(n - 1)种走法，n - 2级台阶存在f(n - 2)种走法，所以f(n) = f(n - 1) + f(n - 2);
//继续递推，完成n - 1级台阶的最后一步时之前肯定走了n - 2或n - 3级台阶，再继续递推，走完n - 2级台阶的最后一步时之前肯定走了n - 3或n - 4级台阶，一直递推下去，则有：f(n) = f(n - 1) + f(n - 2), f(n - 1) = f(n - 2) + f(n - 3), f(n - 2) = f(n - 3) + f(n - 4), f(n - 3) = f(n - 4) + f(n - 5), ......, f(4) = f(3) + f(2), f(3) = f(2) + f(1) 至此，递推结束。
//
//第二步，回归：分析上面递推中的表达式可知，f(n)的结果依赖于f(n - 1)和f(n - 2)，f(n - 1)的结果依赖于f(n - 2)和f(n - 3)，每一项都是未知数，无法求解，只能一直依赖下去，直到最后依赖到f(1)和f(2)的头上，也就是说只要f(1)和f(2)不是未知数，就可以逆着递推的顺序回归到f(n)，解出f(n)。求f(1)和f(2)：根据递推中的假设规律f(1)是指走1级台阶的走法，因为一级台阶只有一种走法，因此f(1) = 1；f(2)是走2级台阶的走法，二级台阶的走法可以是先走一级再走一级或者直接走两级，因此f(2) = 2。
//
//问题就这样解决了，递归代码很好写，但是需要注意当n较大时，由于递归层数多，空间和时间消耗比较大，甚至会出现超时超内存的情况，比在python中默认递归调用深度为1000，当n大于1000时会抛出超过最大调用深度的错误RecursionError : maximum recursion depth exceeded while calling a Python object.因此，往往可以把递归的写法改用循环来实现。
//#include<stdio.h>
//fib(int x)
//{
//	if (x > 2)
//		return fib(x - 1) + fib(x - 2);
//	else if (x == 2)
//		return 2;
//	else
//		return 1;
//}
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	printf("%d", fib(n));
//	return 0;
//}

//BC98 序列中删除指定数字
//有一个整数序列（可能有重复的整数），现删除指定的某一个整数，输出删除指定数字之后的序列，序列中未被删除数字的前后位置没有发生改变。
//
//数据范围：序列长度和序列中的值都满足0≤n≤50
//输入描述：
//第一行输入一个整数(0≤N≤50)。
//
//第二行输入N个整数，输入用空格分隔的N个整数。
//
//第三行输入想要进行删除的一个整数。
//
//输出描述：
//输出为一行，删除指定数字之后的序列。


//如何做到？
//可以搞两个数组，输入 1数组 输出 2数组
//#include<stdio.h>
//
//int main()
//{
//	int i, j;
//	int n = 0;
//	int arr_1[50];
//	int arr_2[50];
//	int del;
//	scanf("%d", &n);
//	for (i = 0; i < n; i++)
//	{
//		scanf("%d", &arr_1[i]);
//	}
//	scanf("%d",&del);
//	for (i = 0, j = 0; i < n; i++)
//	{
//		if (del != arr_1[i])
//		{
//			arr_2[j] = arr_1[i];
//			j++;
//		}
//	}
//	for (i = 0; i < j; i++)
//	{
//		printf("%d ", arr_2[i]);
//	}
//	return 0;
//}

//BC95 最高分与最低分之差
//输入n个成绩，换行输出n个成绩中最高分数和最低分数的差。
//输入描述：
//两行，第一行为n，表示n个成绩，不会大于10000。
//
//第二行为n个成绩（整数表示，范围0~100），以空格隔开。
//输出描述：
//一行，输出n个成绩中最高分数和最低分数的差。

//#include<stdio.h>
//
//int Max(int arr[], int n)
//{
//	int max = arr[0];
//	for (int i = 0; i < n - 1; i++)
//	{
//		if (max < arr[i + 1])
//		{
//			max = arr[i + 1];
//		}
//	}
//	return max;
//}
//int Min(int arr[], int n)
//{
//	int min = arr[0];
//	for (int i = 0; i < n - 1; i++)
//	{
//		if (min > arr[i + 1])
//		{
//			min = arr[i + 1];
//		}
//	}
//	return min;
//}
//int main()
//{
//	int n = 0;
//	scanf("%d", &n);
//	int arr[100];
//	for (int i = 0; i < n; i++)
//	{
//		scanf("%d", &arr[i]);
//	}
//	printf("%d\n", Max(arr, n) - Min(arr, n));
//	return 0;
//}

//BC48 字母大小写转换
//KiKi想完成字母大小写转换，有一个字符，判断它是否为大写字母，如果是，将它转换成小写字母；反之则转换为大写字母。
//输入描述：
//多组输入，每一行输入一个字母。
//输出描述：
//针对每组输入，输出单独占一行，输出字母的对应形式。

//#include<stdio.h>
//
//int main()
//{
//	char ch = '0';
//	while (scanf("%c", &ch) != EOF)
//	{
//		getchar();
//		if ('A' <= ch && ch <= 'Z')
//			ch += 32;
//		else if ('a' <= ch && ch <= 'z')
//			ch -= 32;
//		printf("%c\n", ch);
//	}
//	return 0;
//}

//BC47 判断是不是字母
//KiKi想判断输入的字符是不是字母，请帮他编程实现。
//
//输入描述：
//多组输入，每一行输入一个字符。
//输出描述：
//针对每组输入，输出单独占一行，判断输入字符是否为字母，输出内容详见输出样例。

//#include<stdio.h>
//
//int main()
//{
//	char ch = '0';
//	while (scanf("%c", &ch) != EOF)
//	{
//		getchar();
//		if (('A' <= ch && ch <= 'Z') || ('a' <= ch && ch <= 'z'))
//			printf("%c is an alphabet.\n",ch);
//		else
//			printf("%c is not an alphabet.\n", ch);
//	}
//	return 0;
//}

//BC45 最高分数
//KiKi参加了语文、数学、外语的考试，请帮他判断三科中的最高分。从键盘任意输入三个整数表示的分数，编程判断其中的最高分。
//
//数据范围： 0≤n≤100
//输入描述：
//输入一行包括三个整数表示的分数（0~100），用空格分隔。
//输出描述：
//输出为一行，即三个分数中的最高分。

//#include<stdio.h>
//float Max(int x, int y)
//{
//	if (x > y)
//		return x;
//	else
//		return y;
//}
//int main()
//{
//	float Chinese = 0.0;
//	float Math = 0.0;
//	float English = 0.0;
//	scanf("%f %f %f", &Chinese, &Math, &English);
//	float max = Max(Chinese, Math);
//	max = Max(max,English);
//	printf("%.0f", max);
//	return 0;
//}

////BC38 变种水仙花
//变种水仙花数 - Lily Number：把任意的数字，从中间拆分成两个数字，比如1461 可以拆分成（1和461）, （14和61）, （146和1), 如果所有拆分后的乘积之和等于自身，则是一个Lily Number。
//
//例如：
//
//655 = 6 * 55 + 65 * 5
//
//1461 = 1 * 461 + 14 * 61 + 146 * 1
//
//求出 5位数中的所有 Lily Number。
//
//输入描述：
//无
//输出描述：
//一行，5位数中的所有 Lily Number，每两个数之间间隔一个空格。

//12345 % 10  1234 5
//12345 % 100 123 45
//12345 % 1000 12 345
//12345 % 10000 1 2345

int Lily(int x)
{
	int a1 = x % 10;
	int b1 = x / 10;
	int a2 = x % 100;
	int b2 = x / 100;
	int a3 = x % 1000;
	int b3 = x / 1000;
	int a4 = x % 10000;
	int b4 = x / 10000;
	int y = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4;
	if (x == y)
		return 1;
	else
		return 0;
}
#include<stdio.h>
int main()
{
	//int count = 0;
	for (int n = 10000; n < 100000; n++)
	{
		int ret = Lily(n);
		if (1 == ret)
		{
			printf("%d ", n);
			//count++;
		}
	}
	//printf("\ncount = %d", count);
	return 0;
}

