#define _CRT_SECURE_NO_WARNINGS
//补充：
//release版本会优化
//栈区：先使用高地址
//数组：由低地址到高地址
//release的优化使得内存开辟的方式与默认方式有所差异

//深度婆媳数据在内存中的存储
//1.数据类型介绍
//char 字符数据类型 1
//short 短整型2
// int 整型4
// long 长整型8/4
// long long 更长的整型（C99）8
// float 单精度浮点数4
// double 双精度浮点数8
// 这是c语言内置类型
//
//sizeof(long)<=sizeof(int)
//long: WIN32 : 4 , WIN64 : 8

//类型的意义是
//使用这个类型开辟空间的大小
//看待数据的视角（比如float 和 int，看不同的内容就不同）

//整型家族
// char    自负的本质是ASCII码值，是整型，所以划分到整型家族
//		unsigned char
//		signed char
// char 到底是signed char 还是 unsigned char标准是未定义的，取决于编译器实现。
// 
// 
// short
//		unsigned short
//		signed short(默认写为short)
// int
//		unsigned int 
//		signed int
//	int a; ----> signed int a;(默认)
// long
//		unsigned long
//		signed long(默认写为long)
// 
// long long
//
//生活中有些数据是为没有负数的
// 比如：长度、身高、体重、电话号码等等
// 但是我们
// int a = 0;
// 在WIN32电脑中，表现为32个bit位
//  0000 0000 0000 0000 0000 0000 0000 0000 
// 最高位为符号位
// 符号位为0表示为正数
// 符号位为1表示为负数
// unsigned int a = 0;
//  0000 0000 0000 0000 0000 0000 0000 0000 
// 最高位不是符号位而单纯的是表达数值的
// 

//浮点型家族：只要是表示小鼠就可以使用浮点数
// 
// float精度低，储存的数值范围较小
// double精度高，存储的数值范围更大
// 
// 构造类型：自定义类型 - 我们可以自己创造出新的类型
// -1) 数组类型
// 如 int arr1[5]; 
//	  int arr2[8]; 
// 可以发现不同的数组都不相同，可以随意创建
//  
// -2) 结构体类型struct 
// -3) 枚举类型enum
// -4) 联合类型union
//
//指针类型
//空类型
// void 表示空类型（无类型）
// 通常用于函数的返回类型、函数参数、指针类型。
//eg.1 
// 第一个void表示函数不会返回值，
// 第二个void表示函数不需要传参
//
//void test(void)
//{
//
//}
//int main()
//{
//	return 0;
//}

//整形在内存中的储存
//一个变量的创建是要在内存中开辟空间的
// 数值有不同的表示形式，如2、8、10、16进制
// 如
// 10进制的21
// 2 进制的表现形式为
// 0b10101  （2进制为0b开头）
// 8 进制的表现形式
// 025（8进制开头为0）
// 16进制表现形式为
// 0x15
//
//整数的2进制表示也有三种表示形式：
// 
// 1.正的整数：原码、反码、补码相同
// 2.负的整数：原码、反码、补码是需要计算的
// 
// 原码：直接通过正负的形式写出的二进制序列就是原码
// 反码：原码的符号位不变，其他位按位取反
// 补码：反码+1为补码
// 
// 补码得到原码可以 补码取反加1得到原码
//
//int main()
//{
//	int a = 20;
//	20
//	0000 0000 0000 0000 0000 0000 0001 0100
//	写成16进制
//	0x00 00 00 14
//	内存中实际存储是用的2进制，但是为了显示方便，显示16进制
//	int b = -10;
//	1000 0000 0000 0000 0000 0000 0000 1010 -- 原码
//	 0x80 00 00 0a
//	1111 1111 1111 1111 1111 1111 1111 0101 -- 反码
//	 0xff ff ff f5
//	1111 1111 1111 1111 1111 1111 1111 0110 -- 补码
//	 0xff ff ff f6
//	内存中负数存放的是补码的二进制序列
//	return 0;
//}

//对于证书来说：数据存放的是补码
//在计算机系统中，数值一律用补码来表示和存储
//原因在于，使用补码，可以将符号位和数值域统一处理
//同时，加法和建法也可以统一处理（CPU只有加法器）
//此外，补码与源码相互转化，其运算过程是相同的，
//不需要额外的硬件电路。
//

//大小端问题
//什么是大端小端
// 大端字节序存储：把一个数据的高位字节序的内容存放在低地址处，把低位字节序的内容放在高地址处。
// 小端字节序存储：把一个数据的高位字节序的内容存放在高地址处，把低位字节序的内容放在低地址处。
// 
// 
// 假设：  低地址 -------------> 高地址
// 写16进制数字 0x11 22 33 44
// 总共占四个字节
// 
//
//设计一个程序判断这台机器采用大端字节序存储还是小端字节序存储
#include<stdio.h>
//int main()
//{
//	int a = 1;
//	//0x 00 00 00 01
//	//低地址 -----> 高地址
//	//01 00 00 00 小端
//	//00 00 00 01 大端
//	//判断大小端存储就在于判断它的第一个字节是00 还是 01
//	printf("%d\n", *(char*)&a);
//	//如果是1就是小端
//	//否则大端
//	return 0;
//}

//完整的：
//#include<stdio.h>
//int check_sys()
//{
//	int a = 1;
//	return *(char*)&a;
//}
//int main()
//{
//	int ret = check_sys();
//	if (ret == 1)
//		printf("小端\n");
//	else
//		printf("大端\n");
//	return 0;
//}


//char 的范围 是从 0000 0000 到 1111 1111
//但是signed char 0000 0000 - 0111 1111 为正数  代表 0 ~ 127 ，
// 从1111 1111 到 1000 0000 是 负的： 0 ~ -128
// 其中1000 0000 取反后加1进位了 解析成最小值 为 -128
//无符号char 的范围 0 ~ 255 
//
//short 亦然
// signed short -32768 - 32767
// unsigned short	
//

//int main()
//{
//	char a = -1;
//	//
//	signed char b = -1;
//	//
//	unsigned char c = -1;
//	//首先-1的int类型输出二进制序列是：
//	//1000 0000 0000 0000 0000 0000 0000 0001
//	//1111 1111 1111 1111 1111 1111 1111 1110
//	//1111 1111 1111 1111 1111 1111 1111 1111
//	//但是因为是char类型
//	//截断
//	//截断后八位为char  1111 1111 
//	//打印的时候需要整型提升
//	//因为需要%d int 类型 自动提升为int类型
//	printf("a=%d,b=%d,c=%d", a, b, c);
//
//	//a 1111 1111 
//	//首位为符号位，别的补1
//	//1111 1111 1111 1111 1111 1111 1111 1111
//	//1000 0000 0000 0000 0000 0000 0000 0000
//	//1000 0000 0000 0000 0000 0000 0000 0001
//	//  ---> -1
//	
//	//c 1111 1111
//	//c 无符号数补0
//	//0000 0000 0000 0000 0000 0000 1111 1111
//	// 255
//
//	return 0;
//}


//#include<stdio.h>
//int main()
//{
//	char a = -128;
//	// -128 2进制 2 的 7次方
//	// 1000 0000 0000 0000 0000 0000 1000 0000
//	//截断
//	//1000 0000
//	//提升 1111 1111 1111 1111 1111 1111 1000 0000   按%u打印出
//	//     1000 0000 0000 0000 0000 0000 0111 1111
//	//     1000 0000 0000 0000 0000 0000 1000 0000   按%d打印出
//	//提升完了
//	//%u把第一位看成数据位，并且直接将其作为原码解释，打印无符号整数
//	//%d把第一位看成符号位，需要进行补-->反-->原去转化
//	printf("%u\n", a); 
//	printf("%d\n", a);
//
//	return 0;
//}

#include<stdio.h>
int main()
{
	int i = -20;
	//1000 0000 0000 0000 0000 0000 0001 0100
	//1111 1111 1111 1111 1111 1111 1110 1011
	//1111 1111 1111 1111 1111 1111 1110 1100

	unsigned int j = 10;
	//0000 0000 0000 0000 0000 0000 0000 1010
	//unsigned int 会转化为 int
	//1111 1111 1111 1111 1111 1111 1111 0110
	//1000 0000 0000 0000 0000 0000 0000 1001
	//1000 0000 0000 0000 0000 0000 0000 1010
	//-10
	printf("%d\n", i + j);
	return 0;
}