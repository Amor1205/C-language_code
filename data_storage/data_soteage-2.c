#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<windows.h>
#include<string.h>
#include<assert.h>
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);
//		Sleep(500)
//			;
//	}
//	//0000 0000 0000 0000 0000 0000 0000 0000 
//	// -1 补码全1
//	// 按无符号数角度看解析
//	// 4294967295
//	// 4294967294
//	return 0;
//}

//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;    //a0 = -1 a1 = -2 a2 = -3
//		// -1
//		//提升为int
//		//1000 0000 0000 0000 0000 0000 0000 0001 -- 原码
//		//1111 1111 1111 1111 1111 1111 1111 1111 -- 补码
//		//截断1111 1111 (signed char)
//		// (0 ~ 127 --> -128 ---> -1)
//		// 00000000 --> 01111111 --> 1000 0000 -> 11111111
//		// 1为符号位啊，所以转原码 1000 0000 + 1 --> 1000 0001 所以为-1
//		//-2  同理 1000 0010
//		//-3
//		//...-128 1111 1111
//		//后一位变成了1000 0000 -- 127
//		// 最后变成了0 
//	}
//	printf("%d", strlen(a));
//	//strlen是求字符串的长度，关注的是字符串中‘\0’（数字0）之前出现多少字符
//	//
//	return 0;
//}

//int main()
//{
//	unsigned char i = 0;
//	// 0 - 255 
//	// i = 0 p
//	// i = 1 0000 0001
//	// i = 255 1111 1111
//	// i = 256 1 0000 0000 --> 0000 0000 截断 重新回到0 
//
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hehhe\n");
//	}
//	return 0;
//}

//int main()
//{
//	if (strlen("abc") - strlen("abcdef") >= 0)
//		printf(">\n");
//	else
//		printf("<\n");
//	return 0;
//}
//strlen 是char*类型的返回值
// size_t --> unsigned int
// 3 - 5 = -2 
// 0000 0011
// 
// 0000 0101
// 要做减法先整型提升
// 0000 0000 0000 0000 0000 0000 0000 0011
// 0000 0000 0000 0000 0000 0000 0000 0101
// 减法得到-2
// 1000 0000 0000 0000 0000 0000 0000 0010
// 截断
// 0000 0010
// char只认得到 +2
// 所以输出大于
// 
//如果采用自己设计的my_strlen函数
//int my_strlen(const char* str)
//{
//	assert(str);
//	int count = 0;
//	while (*str)
//	{
//		str++;
//		count++;
//	}
//	return count;
//}
//int main()
//{
//	if (my_strlen("abc") - my_strlen("abcdef") >= 0)
//		printf(">\n");
//	else
//		printf("<\n");
//	return 0;
//}
//有符号数和无符号数相加减，有符号提升为无符号。

//浮点型在内存中的存储

//常见的浮点数
//3.14159
//1E10 1.0*10的十次方
//int相关值定义在limits.h
//float相关值定义在float.h

//例子
//
//int main()
//{
//	int n = 9;
//	float* pFloat = (float*)&n;
//	printf("n的值为：%d\n", n);
//	printf("*pFloat的值为：%f\n", *pFloat);
//	*pFloat = 9.0;
//	printf("n的值为：%d\n", n);
//	printf("*pFloat的值为：%f\n", *pFloat);
//	return 0;
//}
//整数的形式放进去只能用整数的形式往外拿，
//浮点数存---浮点数取，否则都会出现错误
//
//浮点数存储规则
//根基国际标准IEEE 754标准，任何一个二进制浮点数V可以写成下面形式
// V = -1的s次方 * M * 2的E次方
// -1的s次方 表示符号位，s为0，v为正数
// M 表示有效数字，大于等于1，小于2
// 2的E次方表示指数位
//
//举例子
// V = 5.0f
//    101.0
// 化成科学计数法 (-1)^0 * 1.01 * 2^2  (^ 在此时代表 次方 不代表异或) 
// 
// V = 9.5f
// 前面9改成二进制1001，小数点后的权重位 2的-1次方，2的-2次方等等等等。
// 1001.1 --> -1^0 * 1.0011 * 2^3
// 但是 比如写V = 9.6f
// 1001.100.....100001000011000011...
// 有可能会出现永远不会达到9.6但是无限逼近9.6
// float -4byte - 32bit 
// double - 8byte - 64bit 
// 都有可能无法精确保存
// 
// 对于float类型的数据，32位浮点数，最高一位是s，接着8个bit位是指数E，剩余的23个为M
// 对于double，最高S，接着11个为E，剩余52个为M。 
// 但是因为M小数点前面的都为1，所以都省去，计算时计算机再自动加上
// 这样就可以多一位的储存空间
// IEEE 规定 E 为 unsigned 无符号整数
// 但是真实的E可能是为负数，如V = 0.5
// 所以存入内存时E的真实值必须加上一个中间值，对于8位的E，中间值为127，11位加1023
// 这样就不会出现负值。 
// 如本来E为 -1 ， float类型， E存储值为 -1 + 127 = 126 存储进去就是 126  
//
//试一个
//
//int main()
//{
//	float f = 5.5;
//	// 5.5 本来是double类型，但是存在f里面发生隐式类型转换转化为float
//	//5.5
//	//101.1
//	// -1^0 * 1.011 * 2^2
//	// S = 0 ; M = 1.011 E = 2;
//	// S = 0 ; M 存 011 E 存 129;
//	//0 1000 0001 011 0000 0000 0000 0000 0000 
//	// M放在E的后面
//	//0100 0000 1011 0000 0000 0000 0000 0000
//	// 4 0 b 0 00 00 
//
//	return 0;
//}

//指数E从内存中取出还可以分为三种情况：
//1.E不全为0或不全为1
// 这时浮点数采用下列机制：
// E的值减去127或1023，M小数点前补1，就可以得到真实的浮点数。
// 
//2.E全为0
// E不用算了 直接等于1-127 或 1-1023
// M也不再加上第一位的1，而是还原为0.xxxxxx的小数。
// 这样做是为了表示+-0，以及接近于0的很小的数字
//3.E全为1
// 如果有效数字M全为0，表示正负无穷大，看符号位判断正或负。
//
int main()
{
	int n = 9;
	//0000 0000 0000 0000 0000 0000 0000 1001

	float* pFloat = (float*)&n;
	//0 000 0000 0000 0000 0000 0000 0000 1001

	printf("n的值为：%d\n", n);
	
	printf("*pFloat的值为：%f\n", *pFloat);
	
	*pFloat = 9.0; //1001.0 E=3+127 M=1.001
	//0 1000 0010 001 0000 0000 0000 0000 0000
	printf("n的值为：%d\n", n);
	printf("*pFloat的值为：%f\n", *pFloat);
	return 0;
}